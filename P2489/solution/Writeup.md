# P2489 勇者之城

## 思路

题目要求在 N x M 的网格中寻找一条最长的严格递增路径。我们可以从任意格子出发，向上下左右移动到值严格更大的相邻格子。

考虑将网格抽象成一个图。每个格子 `(i, j)` 对应图中的一个节点。如果格子 `(x, y)` 与 `(i, j)` 相邻，并且 `val[i][j] > val[x][y]`，则从代表 `(x, y)` 的节点向代表 `(i, j)` 的节点连一条有向边。

因为边的方向总是从值小的格子指向值大的格子，所以图中不可能存在环。因此，这个图是一个 DAG。

问题转化为求解 DAG 上的最长路径。这是一个经典的动态规划问题，可以通过拓扑排序解决。

设 `dis[u]` 表示以节点 `u` **结尾**的最长路径长度（边的数量）。
1.  初始化所有节点的 `dis` 为 0。
2.  将所有入度为 0 的节点加入队列。
3.  进行拓扑排序：
    *   取出队首（或队尾）节点 `u`。
    *   对于 `u` 的每一个邻居 `v`：
        *   更新 `dis[v] = max(dis[v], dis[u] + 1)`。
        *   将 `v` 的入度减 1。
        *   如果 `v` 的入度变为 0，将其加入队列。
4.  在拓扑排序过程中，记录所有 `dis[v]` 的最大值 `max_dis`。

最终答案即为 `max_dis + 1` （因为 `dis` 记录的是边的数量，路径长度是节点数量）。

## 实现细节

*   可以使用 `m * (x - 1) + y - 1` 将二维坐标 `(x, y)` (假设 1-based) 映射到一维的节点编号 (0-based)。
*   在建图时，只需考虑当前格子 `(i, j)` 与其上方 `(i-1, j)` 和左方 `(i, j-1)` 的格子的大小关系即可，避免重复建边。
*   最后答案是节点数，而代码统计的是边数，最后输出应该加 1。